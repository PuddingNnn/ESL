<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Principal Component Analysis ,Exploratory Factor Analysis and Multidimensinal scaling with zip data</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 14px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:14pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h2>Principal Component Analysis ,Exploratory Factor Analysis and Multidimensinal scaling with zip data</h2>

<p>We report the results in this article to conduct Principal Component Analysis and Factor Analysis with the zip dataset. The main parts are as following:</p>

<ol>
<li> Data description and missing values imputation</li>
<li> Principal component analysis</li>
<li> Factor analysis</li>
<li> Multidimensional scaling</li>
</ol>

<h3>Data Description</h3>

<p>First, we convert the data format to rda in R with the package &#39;sas7bdat&#39; and save it as &#39;zip1.rda&#39; in the working path.
Then we can see the details of the description of the data set.</p>

<pre><code class="r">setwd(&quot;F:/商业数据挖掘_光华/homework/2&quot;)

# library(sas7bdat) read data files
# zip1=read.sas7bdat(&#39;zipdemo1.sas7bdat&#39;) save(zip1,file=&#39;zip1.rda&#39;)
library(xtable)
##### load the data files
load(&quot;zip1.rda&quot;)
print(xtable(head(summary(zip1)[, 1:5])), type = &quot;html&quot;)
</code></pre>

<!-- html table generated in R 2.15.2 by xtable 1.7-1 package -->

<!-- Mon Nov 11 11:42:13 2013 -->

<TABLE border=1>
<TR> <TH>  </TH> <TH>    ZIPCODE </TH> <TH>    DMAWLTHT </TH> <TH>    INCMINDX </TH> <TH>    WEALTHRT </TH> <TH>    PRCWHTE </TH>  </TR>
  <TR> <TD align="right"> 1 </TD> <TD> Min.   : 1001   </TD> <TD> Min.   :0.00   </TD> <TD> Min.   :  3.0   </TD> <TD> Min.   :0.00   </TD> <TD> Min.   :  0.0   </TD> </TR>
  <TR> <TD align="right"> 2 </TD> <TD> 1st Qu.:26071   </TD> <TD> 1st Qu.:2.00   </TD> <TD> 1st Qu.: 69.0   </TD> <TD> 1st Qu.:2.00   </TD> <TD> 1st Qu.: 86.0   </TD> </TR>
  <TR> <TD align="right"> 3 </TD> <TD> Median :49052   </TD> <TD> Median :4.00   </TD> <TD> Median : 84.0   </TD> <TD> Median :3.00   </TD> <TD> Median : 97.0   </TD> </TR>
  <TR> <TD align="right"> 4 </TD> <TD> Mean   :49135   </TD> <TD> Mean   :4.01   </TD> <TD> Mean   : 90.3   </TD> <TD> Mean   :3.63   </TD> <TD> Mean   : 87.9   </TD> </TR>
  <TR> <TD align="right"> 5 </TD> <TD> 3rd Qu.:71292   </TD> <TD> 3rd Qu.:6.00   </TD> <TD> 3rd Qu.:104.0   </TD> <TD> 3rd Qu.:5.00   </TD> <TD> 3rd Qu.: 99.0   </TD> </TR>
  <TR> <TD align="right"> 6 </TD> <TD> Max.   :99929   </TD> <TD> Max.   :9.00   </TD> <TD> Max.   :409.0   </TD> <TD> Max.   :9.00   </TD> <TD> Max.   :100.0   </TD> </TR>
   </TABLE>

<pre><code class="r">sum(!complete.cases(zip1))
</code></pre>

<p>[1] 908</p>

<p>Some NAs are included in some variables. So we simply conduct the multiple imputation with the &#39;mi&#39; package in R. Since the it takes a long time to do such process, we just save the imputated dataset before. Here we also deplay the codes.</p>

<pre><code class="r">##### conduct the multiple imputation require(mi) zip1_com = mi(zip1[,-1])
##### comp_zip1 = mi.data.frame(zip1_com,m=1) zip1_comp =
##### cbind(zip1[,1],comp_zip1) save(zip1_comp,file=&#39;zip1_comp.rda&#39;)
load(&quot;zip1_comp.rda&quot;)
</code></pre>

<pre><code>## Warning: cannot open compressed file &#39;zip1_comp.rda&#39;, probable reason &#39;No
## such file or directory&#39;
</code></pre>

<pre><code>## Error: cannot open the connection
</code></pre>

<pre><code class="r">summary(zip1_comp)
</code></pre>

<pre><code>## Error: object &#39;zip1_comp&#39; not found
</code></pre>

<h3>Principal Component Analysis</h3>

<p>We conduct the principal component analysis using the function princomp. The correlation matrix is used for the estimation.</p>

<pre><code class="r">#### Principal Component Analysis
dd = zip1_comp[, -1]
</code></pre>

<pre><code>## Error: object &#39;zip1_comp&#39; not found
</code></pre>

<pre><code class="r">zip_prin = princomp(dd, cor = T, scores = T)
</code></pre>

<pre><code>## Error: object &#39;dd&#39; not found
</code></pre>

<p>Then we draw the scree plot to select the appropriate component number. There&#39;s a turning point at Comp.5 in the picture, so we simply choose 5 as the component number, which explains
74.98 percent of the variance.</p>

<pre><code class="r">screeplot(zip_prin, type = &quot;lines&quot;)
</code></pre>

<pre><code>## Error: object &#39;zip_prin&#39; not found
</code></pre>

<p>we summary the results for details of the components. Besides, if we follow the Kaiser Principle, we&#39;d better to choose 6 as the component number, which explains 78.35 percent variance.</p>

<pre><code class="r">summary(zip_prin)
</code></pre>

<pre><code>## Error: object &#39;zip_prin&#39; not found
</code></pre>

<p>In addition, we look into the loading matrix to achieve more information.</p>

<p>The first component is about the population age distribution against the wealth indicators. </p>

<p>The second mainly describes the races distribution and wealth ratings against some other indicators like ages and NCDB. </p>

<p>The third contains the comparison about the races structure and wealth indexes, ages, salary structures etc. </p>

<p>Other components can also be analyzed in this way. </p>

<p>To summary, the variables can be clustered into aspects about wealth, salary structures, social positions, human races structures, age structures etc.</p>

<pre><code class="r">loadings(zip_prin)
</code></pre>

<pre><code>## Error: object &#39;zip_prin&#39; not found
</code></pre>

<h3>Factor Analysis</h3>

<p>We conduct the Factor Analysis with the MLE method. To avoid the scaling problem, we center and scale the variables with zero mean and 1 sd.</p>

<p>Besides, we use the varimax principle to conduct the rotation.</p>

<pre><code class="r">#### Factor Analysis
dd_std = scale(dd)
</code></pre>

<pre><code>## Error: object &#39;dd&#39; not found
</code></pre>

<pre><code class="r">zip_fac = factanal(dd_std, factor = 10, rotation = &quot;varimax&quot;, n.obs = nrow(dd), 
    control = list(trace = T))
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<pre><code class="r">zip_fac
</code></pre>

<pre><code>## Error: object &#39;zip_fac&#39; not found
</code></pre>

<h4>Several ways to decide Number of Factors</h4>

<p>We use the principle that every factor&#39;s variance&#39;s ratio should be larger than 1/p. Since the variance of the X (all variance) is p (32), we just need to guarantee that the factor&#39;s variance is larger than 1.</p>

<pre><code class="r">flag = 1
i = 15
while (flag == 1) {
    zip_fac = factanal(dd_std, factor = i, rotation = &quot;varimax&quot;, n.obs = nrow(dd))
    fac_var = apply(zip_fac$loadings, 2, function(x) return(sum(x^2)))
    cat(&quot;nFactor:&quot;, i, &quot;\n&quot;, &quot;Factor variance:&quot;, fac_var, &quot;\n&quot;, &quot;\n&quot;)
    if (all(fac_var &gt;= 1)) 
        flag = 0
    i = i - 1
}
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<p>Here 8 is the number of the factors that subject to the constraint.</p>

<p>Besides that, we can also use the eigenvalues to decide the number. According to the principal component analysis before, we can choose 6 as our number of factors, which accounts for 78.34 percent of the sum of eigenvalues. We can also make other choices due to the demanded cumulative proportion in the summary(zip_prin) before.</p>

<p>The parallel analysis is also a way to decide the number of factors, which is developed by Raiche, Riopel, and Blais. We the R package &#39;nFactors&#39; fot the analysis.</p>

<pre><code class="r"># Determine Number of Factors to Extract
library(nFactors)
ev &lt;- eigen(cor(dd_std))  # get eigenvalues
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<pre><code class="r">ap &lt;- parallel(subject = nrow(dd_std), var = ncol(dd_std), rep = 100, cent = 0.05)
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<pre><code class="r">nS &lt;- nScree(x = ev$values, aparallel = ap$eigen$qevpea)
</code></pre>

<pre><code>## Error: object &#39;ev&#39; not found
</code></pre>

<pre><code class="r">plotnScree(nS)
</code></pre>

<pre><code>## Error: object &#39;nS&#39; not found
</code></pre>

<p>The result gives 6 as the best number.</p>

<p>There are other methods provided in this package for the number decision process.</p>

<pre><code class="r">nBartlett(x = ev$values, N = nrow(dd_std), alpha = 0.05, details = TRUE)
</code></pre>

<pre><code>## Error: object &#39;ev&#39; not found
</code></pre>

<pre><code class="r">nBentler(x = ev$values, N = nrow(dd_std), alpha = 0.05, details = TRUE)
</code></pre>

<pre><code>## Error: object &#39;ev&#39; not found
</code></pre>

<pre><code class="r">nCng(x = ev$values, model = &quot;factors&quot;, details = TRUE)
</code></pre>

<pre><code>## Error: object &#39;ev&#39; not found
</code></pre>

<h4>Factor Explainations</h4>

<p>We choose 6 as the factor numbers. </p>

<p>We then use the varimax and promax rotation method to achieve the loading matrix.</p>

<pre><code class="r">#### Factor Analysis
dd_std = scale(dd)
</code></pre>

<pre><code>## Error: object &#39;dd&#39; not found
</code></pre>

<pre><code class="r">zip_fac = factanal(dd_std, factor = 6, rotation = &quot;varimax&quot;, n.obs = nrow(dd))
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<pre><code class="r">loadings(zip_fac)
</code></pre>

<pre><code>## Error: object &#39;zip_fac&#39; not found
</code></pre>

<pre><code class="r">zip_fac = factanal(dd_std, factor = 6, rotation = &quot;promax&quot;, n.obs = nrow(dd))
</code></pre>

<pre><code>## Error: object &#39;dd_std&#39; not found
</code></pre>

<pre><code class="r">loadings(zip_fac)
</code></pre>

<pre><code>## Error: object &#39;zip_fac&#39; not found
</code></pre>

<p>From the loading matrix we can see the promax rotation are closely related to the varimax rotation in the top3 factors. We now look into more details of the loading matrix of the promax rotation.</p>

<p>The first factor has a high loading value at WEALTHRT, DMAWLTHT, INCMINDX and CEMI, they are mainly about the income index. And it has relative negative loading on PRCBLCK, PRCNCD1 and PRCRENT compared to the first aspect, which are mainly  related to the human races percent.</p>

<p>The second factor are mostly the PRCNCD3, PRCNCD10 aginst PRCNCD1 and PRCOWNO. They are mainly the descriptions of the %NCDB HH.</p>

<p>The third has a high loading on PRC500K, PRC200K, PRC100K and OOMEDHVL. They are mainly about the OOH Value.</p>

<p>The fourth factor has the highest loading on PRC65P, HHMEDAGE, PRC55P and a relative negative value on PRC3544, PRC4554. They are mostly descriptions of the age structure.</p>

<p>The fifth factor is highest loaded on PRCUN18, PRCTHRE and PRCHHFM. They have a closed relationship with the %HH value.</p>

<h4>Multidimensional Scaling</h4>

<p>We use the package MASS to do the multidimensional scaling with data zip2. For details, we use 1-correlation as the distance measure.</p>

<pre><code class="r">library(&quot;MASS&quot;)
library(ggplot2)
load(&quot;zip2.rda&quot;)
</code></pre>

<pre><code>## Error: cannot open the connection
</code></pre>

<pre><code class="r">dist = 1 - cor(zip2[, -1])
</code></pre>

<pre><code>## Error: object &#39;zip2&#39; not found
</code></pre>

<pre><code class="r">
zip2_mds = isoMDS(dist)
</code></pre>

<pre><code>## Error: default method not implemented for type &#39;closure&#39;
</code></pre>

<pre><code class="r">x = zip2_mds$points[, 1]
</code></pre>

<pre><code>## Error: object &#39;zip2_mds&#39; not found
</code></pre>

<pre><code class="r">y = zip2_mds$points[, 2]
</code></pre>

<pre><code>## Error: object &#39;zip2_mds&#39; not found
</code></pre>

<pre><code class="r">g = ggplot(data.frame(x, y), aes(x, y, label = colnames(zip2)[-1]))
</code></pre>

<pre><code>## Error: object &#39;x&#39; not found
</code></pre>

<pre><code class="r">g + geom_point(shape = 16, size = 3, colour = &quot;red&quot;) + geom_text(hjust = -0.1, 
    vjust = 0.5, alpha = 0.5, angle = 7)
</code></pre>

<pre><code>## Error: object &#39;g&#39; not found
</code></pre>

<p>From the figure, we can see some features are clustered with each other.</p>

<p>The CEMI, PRC25BA, OOHVI, PRCOOHV, ISPSA, WEALTHRT, DMAWLTHT, MEDSCHYR are very closed to each other. That means the wealth ,the education level and the social position are high correlated.</p>

<p>The PRC65P, HHMEDAGE, PRC55P are very closed. They are all descriptions of ages. We may infer that the householder&#39;s median age are upon 55.</p>

<p>The PRC200K, PRC100K, OOHVI are very closed to each other. </p>

<p>There isn&#39;t a significant clustering sign of other features.</p>

</body>

</html>

